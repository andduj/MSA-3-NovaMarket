# ADR-001: Выбор паттерна для агрегации данных истории заказов

## Статус
Принято

## Дата
2024-12-19

## Контекст
Для реализации функциональности "Просмотр истории покупок" необходимо выбрать архитектурный паттерн, который обеспечит:
- Быстрый отклик (≤ 1 секунды в 99.99% случаев, ≤ 0.3 секунды в 98% случаев)
- Агрегацию данных из нескольких микросервисов (Order Service, Payment Service, Delivery Service, Catalog Service)
- Масштабируемость при росте нагрузки до 40,000+ заказов в день
- Возможность легкого добавления новых функций (отзывы, чеки, повторные заказы)

## Рассмотренные варианты

### 1. API Composition
**Описание**: Создание композитного API, который собирает данные из нескольких микросервисов через синхронные HTTP-вызовы.

**Плюсы**:
- Простота реализации
- Не требует дополнительной инфраструктуры
- Актуальные данные в реальном времени

**Минусы**:
- Высокая латентность из-за множественных HTTP-вызовов
- Сложность обработки частичных отказов
- Плохая масштабируемость при росте количества сервисов
- Нарушение требований к производительности (≤ 0.3 сек в 98% случаев)

### 2. CQRS (Command Query Responsibility Segregation)
**Описание**: Разделение операций записи (Commands) и чтения (Queries) с отдельными оптимизированными моделями данных.

**Плюсы**:
- Оптимизированные модели для чтения
- Высокая производительность запросов
- Возможность независимого масштабирования read/write моделей
- Гибкость в выборе технологий для read модели

**Минусы**:
- Увеличенная сложность архитектуры
- Необходимость синхронизации между write и read моделями
- Дополнительная инфраструктура (Event Store, проекторы)

### 3. Event Sourcing
**Описание**: Хранение всех изменений состояния как последовательности событий с возможностью восстановления состояния в любой момент времени.

**Плюсы**:
- Полный аудит всех изменений
- Возможность воспроизведения событий
- Временные запросы (состояние на определенную дату)
- Естественная интеграция с CQRS

**Минусы**:
- Высокая сложность реализации
- Сложность запросов по текущему состоянию
- Требует специальной инфраструктуры (Event Store)
- Кривая обучения для команды

### 4. Комбинация CQRS + Event Sourcing
**Описание**: Использование Event Sourcing для write модели и CQRS для оптимизированных read моделей.

**Плюсы**:
- Все преимущества CQRS и Event Sourcing
- Максимальная гибкость и производительность
- Возможность сложных аналитических запросов
- Полный аудит и возможность отката изменений

**Минусы**:
- Максимальная сложность реализации
- Высокие требования к инфраструктуре
- Сложность отладки и мониторинга

## Принятое решение

**Выбрана комбинация CQRS + Event Sourcing** с фокусом на CQRS для решения текущих задач.

### Обоснование

1. **Производительность**: CQRS позволяет создать оптимизированную read модель, специально настроенную для быстрых запросов истории заказов, что критично для выполнения требований к отклику.

2. **Масштабируемость**: Read модель может масштабироваться независимо от write модели, что важно при росте до 40,000+ заказов в день.

3. **Гибкость**: CQRS позволяет легко добавлять новые read модели для новых функций (отзывы, чеки, аналитика) без влияния на существующую архитектуру.

4. **Event Sourcing как основа**: Event Sourcing обеспечивает надежную основу для CQRS, позволяя воспроизводить события и создавать новые read модели.

### Архитектурные компоненты

1. **Event Store** (EventStoreDB) - хранение всех доменных событий
2. **Order History Service** - проектор событий в read модель
3. **Order History Read DB** - оптимизированная PostgreSQL для запросов истории
4. **Event Handlers** - обработчики событий для обновления read модели

### Схема работы

1. Write операции (создание заказа, обновление статуса) сохраняют события в Event Store
2. Order History Service подписывается на события через Kafka
3. При получении событий проектор обновляет read модель в Order History Read DB
4. API Gateway направляет запросы истории заказов в Order History Service
5. Order History Service возвращает агрегированные данные из read модели

## Последствия

### Положительные
- Выполнение требований к производительности
- Возможность независимого масштабирования
- Легкое добавление новых функций
- Полный аудит всех операций

### Отрицательные
- Увеличенная сложность разработки
- Необходимость обучения команды
- Дополнительная инфраструктура
- Сложность отладки

### Риски и митигация
- **Риск**: Сложность реализации может привести к задержкам
  - **Митигация**: Поэтапная реализация, начиная с простого CQRS
- **Риск**: Проблемы с синхронизацией read/write моделей
  - **Митигация**: Eventual consistency, индикаторы синхронизации
- **Риск**: Высокие требования к инфраструктуре
  - **Митигация**: Использование managed сервисов (EventStoreDB Cloud)

## Альтернативы на будущее

При росте системы можно рассмотреть:
- **Materialized Views** для простых агрегаций
- **Data Warehouse** для аналитических запросов
- **GraphQL** для гибких запросов клиентов
